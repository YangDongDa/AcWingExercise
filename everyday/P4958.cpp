// 对于一个长度为 K
//  的整数数列：A1,A2,...,AK
// ，我们称之为接龙数列当且仅当 Ai
//  的首位数字恰好等于 Ai−1
//  的末位数字 (2≤i≤K
// )。
//
// 例如 12,23,35,56,61,11
//  是接龙数列；12,23,34,56
//  不是接龙数列，因为 56
//  的首位数字不等于 34
//  的末位数字。
//
// 所有长度为 1
//  的整数数列都是接龙数列。
//
// 现在给定一个长度为 N
//  的数列 A1,A2,...,AN
// ，请你计算最少从中删除多少个数，可以使剩下的序列是接龙序列？
#include <iostream>
#include <bits/stdc++.h>
using namespace std;
//l[i]表示第i个数的首位数字,r[i]表示第i个数的末位数字
int l[100005], r[100005];
//f[i]表示以第i个数结尾的最长接龙序列的长度,g[i]表示以第i结尾的最长接龙序列的长
int f[100005], g[11];

int main (int argc, char *argv[])
{
    int n;
    cin >> n;
    int mx = 0;
    for (int i = 1; i <= n; i++)
    {
        string s;
        cin >> s;
        r[i] = s[s.size() - 1] - '0';
        l[i] = s[0] - '0';
    }
   /* 
    //对于每个数，找到最长的接龙序列
    for(int i = 1 ; i <= n; i++){
        f[i] = 1;

        //找到能到达第i个数的最长接龙序列
        for(int j = 1; j < i; j++){

            //如果第j个数的末位数字等于第i个数的首位数字,则可以到达第i个数
            if(r[j] == l[i]){

                //更新以第i个数结尾的最长接龙序列的长度
                f[i] = max(f[i], f[j] + 1);
            }
        }
        //更新最长接龙序列的长度
        mx = max(mx, f[i]);

    }
    */

    //优化
    for(int i = 1; i <= n ; i++){
        f[i] = 1;

        //找到能到达第i个数的最长接龙序列
        f[i] = max(g[l[i]] + 1, f[i]);

        //维护以第i个数结尾的最长接龙序列的长度
        g[r[i]] = max(g[r[i]] , f[i]);

        //更新最长接龙序列的长度
        mx = max(mx, f[i]);
    }
    cout << n - mx << endl;

    return 0;
}
